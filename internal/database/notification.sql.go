// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: notification.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getNotifications = `-- name: GetNotifications :many
SELECT id, user_id,prose_id, actors, type, read, generated_at FROM notifications WHERE user_id=$1
AND $2::TIMESTAMP IS NULL OR generated_at < $2
ORDER BY generated_at DESC
LIMIT $3
`

type GetNotificationsParams struct {
	UserID  pgtype.UUID
	Column2 pgtype.Timestamp
	Limit   int32
}

type GetNotificationsRow struct {
	ID          pgtype.UUID
	UserID      pgtype.UUID
	ProseID     pgtype.UUID
	Actors      []string
	Type        string
	Read        bool
	GeneratedAt pgtype.Timestamp
}

func (q *Queries) GetNotifications(ctx context.Context, arg GetNotificationsParams) ([]GetNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getNotifications, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsRow
	for rows.Next() {
		var i GetNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProseID,
			&i.Actors,
			&i.Type,
			&i.Read,
			&i.GeneratedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCommentNotification = `-- name: InsertCommentNotification :one
INSERT INTO notifications(id, user_id,actors,type,prose_id,generated_at ) VALUES($1,$2,$3, 'comment',$4,$5) ON CONFLICT (user_id,actors,type,read) 
DO UPDATE SET actors= append_array(actors,$3), generated_at=$5
RETURNING id,generated_at,actors
`

type InsertCommentNotificationParams struct {
	ID          pgtype.UUID
	UserID      pgtype.UUID
	Actors      []string
	ProseID     pgtype.UUID
	GeneratedAt pgtype.Timestamp
}

type InsertCommentNotificationRow struct {
	ID          pgtype.UUID
	GeneratedAt pgtype.Timestamp
	Actors      []string
}

func (q *Queries) InsertCommentNotification(ctx context.Context, arg InsertCommentNotificationParams) (InsertCommentNotificationRow, error) {
	row := q.db.QueryRow(ctx, insertCommentNotification,
		arg.ID,
		arg.UserID,
		arg.Actors,
		arg.ProseID,
		arg.GeneratedAt,
	)
	var i InsertCommentNotificationRow
	err := row.Scan(&i.ID, &i.GeneratedAt, &i.Actors)
	return i, err
}

const insertNotification = `-- name: InsertNotification :exec
INSERT INTO notifications(id,user_id,actors,type,generated_at) VALUES($1,$2,$3,$4,$5)
`

type InsertNotificationParams struct {
	ID          pgtype.UUID
	UserID      pgtype.UUID
	Actors      []string
	Type        string
	GeneratedAt pgtype.Timestamp
}

func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) error {
	_, err := q.db.Exec(ctx, insertNotification,
		arg.ID,
		arg.UserID,
		arg.Actors,
		arg.Type,
		arg.GeneratedAt,
	)
	return err
}

const notificationActorExists = `-- name: NotificationActorExists :one
SELECT EXISTS 
(SELECT 1 FROM notifications WHERE user_id=$1 AND type='folllow' AND  $2::VARCHAR= ANY(actors) AND read=false) as exists
`

type NotificationActorExistsParams struct {
	UserID  pgtype.UUID
	Column2 string
}

func (q *Queries) NotificationActorExists(ctx context.Context, arg NotificationActorExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, notificationActorExists, arg.UserID, arg.Column2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const notificationExists = `-- name: NotificationExists :one
SELECT id FROM notifications WHERE user_id=$1 AND type='follow' AND read=false
`

func (q *Queries) NotificationExists(ctx context.Context, userID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, notificationExists, userID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const readNotificationAll = `-- name: ReadNotificationAll :exec
UPDATE notifications SET read=true WHERE user_id=$1
`

func (q *Queries) ReadNotificationAll(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, readNotificationAll, userID)
	return err
}

const readNotificationSingle = `-- name: ReadNotificationSingle :exec
UPDATE notifications SET read= true WHERE user_id=$1 AND id=$2
`

type ReadNotificationSingleParams struct {
	UserID pgtype.UUID
	ID     pgtype.UUID
}

func (q *Queries) ReadNotificationSingle(ctx context.Context, arg ReadNotificationSingleParams) error {
	_, err := q.db.Exec(ctx, readNotificationSingle, arg.UserID, arg.ID)
	return err
}

const updateNotification = `-- name: UpdateNotification :one
UPDATE notifications 
SET actors= append_array(actors,$1::VARCHAR) 
AND generated_at=$2 
WHERE id=$3 RETURNING actors
`

type UpdateNotificationParams struct {
	Column1     string
	GeneratedAt pgtype.Timestamp
	ID          pgtype.UUID
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) ([]string, error) {
	row := q.db.QueryRow(ctx, updateNotification, arg.Column1, arg.GeneratedAt, arg.ID)
	var actors []string
	err := row.Scan(&actors)
	return actors, err
}
